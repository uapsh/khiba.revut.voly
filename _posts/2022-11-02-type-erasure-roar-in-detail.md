## Як стерти тип? Aбо не наслідуванням єдиним. Англо-сакський type-erasure

Дуже часто нам, програмістам, доводиться працювати з таким поняттям як поліморфізм. В С++ його виконання може набувати кілька форм.
Найбільш популярна це віртуальні функції та басові-класи "інтерейси" - так званий *динамічний поліморфізм*. 
Він породжує системи, де вказівники на базовий клас є ключовими, не гріх викоритати dynamic_cast, switch, є поняття віртуальних функцій, і неможливість додати той чи інший функціонал без "моменту наслідування".
Доволі часто наслідники імплементуються вільно, беручи до уваги не інтерейс, а потребу в тому чи іншому функціоналі, вивчають можливості обійти інтерфейс, додати кілька не потрібних залежностей, або розширити інтерфейс за будь-якої нагоди ... і так далі. ~~Не будемо євангелістами, та визнаймо, що на реальних проектах ситуації не завжди, м'яко кажучи, хрестоматійні~~
Мінусів підходу за роки існування С++ можна назвати безліч, так як і знайти прихильників в тій чи іншій стороні. 
Проте сучасні тенденції С++ змушують задуматися про альтернативи такого світу (який вже дуууже давно існує і використовуються у кращих домах Києва).  
В рамкаї даного тексту, я б хотів розглянути іншу сторону поліморфізму в С++ - зовнішній поліморфізм та "стирання типів" (type-erasure).

### Чи є життя поза "динамічним поліморфізмом"?
Проста відповідь - є. Складна відповідь далі...

Отже, запитавши пересічного С++ кандидата у вашу команду про поліморфізм, він почне з динамічного та закінчить статичним,  припише CRTP. Хтось почне філософію уяви і переконає Вас що і в С поліморфізм є, і навіть успішний, деякі навіть наведуть приклад суміжних мов, які вирішують ці питання по іншому - як от Swift, Rust, Java, Python. Хороший кандидат буде. 

Почнемо з пересічного, підемо поняттям *статичний поліморфізм*.
Його виконання зводиться до використання шаблонних функцій в тій чи іншій мірі та принципу ["качиної типізації"](https://uk.wikipedia.org/wiki/%D0%9A%D0%B0%D1%87%D0%B8%D0%BD%D0%B0_%D1%82%D0%B8%D0%BF%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F):

```cpp
struct Rock {
  void print() const { std::cout << "Rock\n"; }
};

struct Paper {
  void print() const { printf("Paper\n"); }
};

struct Scissors {
  void print() const { std::cout << "Scissors\n"; }
};

struct Printer {
  template <class T> void print(const T &object) { object.print(); }
};

Printer p;
p.print(Rock{});
p.print(Paper{});
p.print(Scissors{});
```
Шаблонний клас (чи то функція) накладає певні вимоги на тип переданого параметру, таким чином формується інтерфейс, прямо на етапі компіляції. Доволі неявно. 

Варто підмітити дуже важливу особливість - поліморфізм реалізується без використання наслідування та звичайних базових класів, як основи на яку можна покладатися в класах імлементаціях, а також відсутністю віртуальних функцій. Це робить наші клас більш незалежними, проте і назвати їх сімейством не дуже коректно. 

Удосконалити `Printer` можна за допомогою [SFINAE](https://uapsh.github.io/khiba.revut.voly/2022/09/20/sfinae-roar-in-details.html) або [концептів](https://uapsh.github.io/khiba.revut.voly/2022/10/03/enableif-roar-in-details.html) проте це вже межі інших текстів. 

Часто можна згадати прийом, який зветься [CRTP](https://uk.wikipedia.org/wiki/%D0%94%D0%B8%D0%B2%D0%BD%D0%BE_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%B8%D0%B9_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD) та приліпити його до поліморфізму. 

Загальна ідея наступна:
```cpp
template <typename Derived> struct Item {
  void print() const { return static_cast<const Derived *>(this)->printImpl(); }
};

struct Rock : Item<Rock> {
  void printImpl() const { std::cout << "Rock\n"; }
};

struct Paper : Item<Paper> {
  void printImpl() const { printf("Paper\n"); }
};

struct Scissors : Item<Scissors> {
  void printImpl() const { std::cout << "\n"; }
};
```

Тут інтерфейс теж не явний і диктується компіляцією. Проте вже є базовий клас, шаблонна природа якого, робить його різним для кожного окремого наслідника. Тут спільного батька немає. 

> "Наслідування це базовий клас зла" - Шон Парент

Примітка: CRTP не зовсім коректний інструмент для поліморфізму, його використання є швидще задля генералізації загального функціоналу, не так як надання базового інтерфейсу. Наприклад [`counter`](https://uk.wikipedia.org/wiki/%D0%94%D0%B8%D0%B2%D0%BD%D0%BE_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%B8%D0%B9_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD#%D0%9B%D1%96%D1%87%D0%B8%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA%20%D0%BE%D0%B1'%D1%94%D0%BA%D1%82%D1%96%D0%B2:~:text=%D1%96%20WTL.-,%D0%9B%D1%96%D1%87%D0%B8%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA%20%D0%BE%D0%B1%27%D1%94%D0%BA%D1%82%D1%96%D0%B2,-%5B%D1%80%D0%B5%D0%B4.) описаний у Вікіпедії. 

Обидва приклади, звісно що, не позбавлені мінусів. Наприклад, ми хочемо зберегти елементи в контейнері. Використовуючи звичайний масив, чи то вектор це неможливо - в нас немає спільного базового класу, який би був одинаковий для всіх. Це приводить нас до використання `std::tuple`, `std::variant`, та інших прийомів.

Наприклад: 

```cpp
std::variant<Rock, Paper, Scissors> items;
std::visit([](auto &r) { r.print(); }, items);
```

Це цілком вагомий аргумент проти. Проблема шаблонності тої чи іншої сторони статичного поліморфізму описаного вище змушує таки задуматися про повернення до динамічного поліморфізму. ~~Так він явно кращий. Давайте таки будемо використовувати його і не переживати. Кінець.~~

То як нам мати гнучнкість не повязану з використанням шаблонної магії та водночас не вписувати шаблонні класи на кожному кроці? 

Саме тут на допомогу приходить так званне "стирання типів" (англ. type-erasure) та в певній мірі принцип зовнішнього поліморфізму. 


### Зітремо тип
Отже, аби усунути пролему явної типізації при використанні шаблонів, мати гнучний механізм роботи з класами, які не повязані наслідуванням, не завязані на ієрархічні структури і дозволяють працювати з ними за допомогою абстракцій та значень (а не вказівників) ми застосуємо прийом "стирання типу". 

В основі лежать кілька китів: 
* паттерн bridge 
* шаблонний конструктор 
* семантика значень (value semantic)
* поверхнево розглянемо також і принцим зовніщнього поліморфізму. 

Питання: Як нам зберігати об'єкт невідомого типу, в шаблонному контексті оминаючи згадки про тип ? 
Відповідь: Зберігати не шаблонну сутнність, яку можна підмінити на шаблонну на етапі компіцляції. Без наслідування в цьому моменті ніяк.  

Аби класи в нашій ієрархії мали можливіть працювати через один інтерфейс, нам як не як треба його створити, як і абстрацію з якою ми працюватимемо: 

```cpp
class Item {
    struct ItemConceptBase {
        virtual ~ItemConceptBase() = default;
        virtual void print() = 0;
    };

    template <typename T> 
    struct ItemConcept : ItemConceptBase {
    public:
        ItemConcept(const T& printee)
            : m_printee(printee)        {
        }
        void print() override {
            m_printee.print();
        }

    private:
        T m_printee;
    };

public:
    template <typename Printable>
    Item(const Printable& p)
        : m_pimpl(new ItemConcept<Printable>(p)) {
    }

    void print() {
        m_pimpl->print();
    }

private:
    std::unique_ptr<ItemConceptBase> m_pimpl;
};

```

Клас `Item` може тримати в собі об'єкти будь-якого типу завдяки шаблонному конструктору. Аби сам клас не був шаблонний, нам потрібно уникнути в ньому шаблонних даних - це завдання класу `ItemConceptBase`. Аби шаблонна природа збереглася існує класс `ItemConcept`. Це дозволить зробити наступне:
```cpp
struct Rock {};
struct Paper {};
struct Scissors {};

std::vector<Item> items;
items.emplace_back(Rock{});
items.emplace_back(Paper{});
items.emplace_back(Scissors{});

for (auto& item : items)
{
    item.print();
}
```

Основна вимога поліморфної поведінки це наявність методу `print` в класах. які ми передаємо в `Item`. Проте і такі вимоги можна розширити додавши клас-стратегію як аргумент шаблонного конструктора. 

```cpp
template <typename Printable, typename PrintStrategy>
Item(const Printable& p, const PrintStrategy& s)
        : m_pimpl(new ItemConcept<Printable, PrintStrategy>(p, s)) 
{
}
```

Маючи `PrintStrategy` ми можемо частково говорити про зовнішній поліморфізм це операції виконуються функціями поза межами класу, що може бути гнучко. 

Отже, поліморфізм таки існує без наслідування, хоча не зовсім в повній мірі. "Стирання типів" це прийом який вартий уваги і досить розумно спробувати його у вашій роботі. 
 
### Фуу... шаблони, вони не читабельні, люди не люблять шаблони, час коміляції довший ... і взагалі інтерфейси простіші

Нас лякає те чого ми не розуміємо. Мета тексту не пропаганда певних методик, а лиш огляд можливостей, які вони приносять. 

В реальності, зміна методик може бути важким процесом і завжди повинна мати причину. 

Причини використовувати статичний поліморфізм та "стирання типів" можуть бути різні, відходячи від навичок команди та необхідністю оптимізувати певні процеси. Також використання цих принципів позитивно впливають на архітектуру коду, зменшують залежності, там формують більш чіткі рамки диктовані компілятором чи типами. З цим всім можна сперечатися вічно....

### Переваги статичного поліморфізму
* Легко реалізуються колекції вбудованих типів. У більш загальному випадку, спільність інтерфейсу не обов'язково виражати через спільний базовий клас.
* Згенерований код є потенційно швидшим (оскільки апріорі не потрібна опосередкованість через вказівники і
* невіртуальні функції можна вбудовувати набагато частіше)
* Конкретні типи, які надають лише часткові інтерфейси, все ще можуть використовуватися,тільки  якщо ця частина в кінцевому підсумку буде використовуватись в програмі.

### Детальніше про описане тут

* [Type Erasure Desing Analysis](https://meetingcpp.com/mcpp/slides/2021/Type%20Erasure%20-%20A%20Design%20Analysis9268.pdf)
* [GoingNative 2013 Inheritance Is The Base Class of Evil](https://www.youtube.com/watch?v=2bLkxj6EVoM)
* [External Polymorphism](https://www.dre.vanderbilt.edu/~schmidt/PDF/C++-EP.pdf)

